package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;
    
    private ArrayList<Tuple> _outerTuples=null;
    private ArrayList<Tuple> _innerTuples=null;
   
 
    private int numberOfouterPages;
    private int[] numberOfTuplesInOuterPage;
    private ArrayList<Tuple> outerTuples;
    private ArrayList<Tuple> outerTuples2;
    private int outerPage=1;
    
    private int numberOfinnerPages;
    private int[] numberOfTuplesInInnerPage;
    private ArrayList<Tuple> innerTuples;

    private ArrayList<Tuple> joinResultLeftHalf;
    private ArrayList<Tuple> joinResultRightHalf;
   
    
    private int pos=0;
    private int numberOfTuples = 0;
    
    
    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;
    
    private int _outerSize=0;
    private int _innerSize=0;
    private int _outerIndex=0;
    private int _innerIndex=0;
 
    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;

    
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;    
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
	//IMPLEMENT THIS
    	if((child1==null)||(child2==null))
    	 System.out.println("child 1 or child 2 is null");
    	this._outerRelation=child1;
    	this._innerRelation=child2;
    	this._predicate=p;
    }

    public void setJoinAlgorithm(int joinAlgo){
    	if(joinAlgo==this.PNL){
    		try{
    		this._outerRelation.open();
    		this._innerRelation.open();
    		this.PNL_supportMethod();
    		this._innerRelation.close();
    		this._outerRelation.close();
    		}// end of try
    		catch (Exception e){
    			
    			e.printStackTrace();
    		}// end of catch
    	}//end of if
	_joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
    	//IMPLEMENT THIS
	 TupleDesc td1 = this._outerRelation.getTupleDesc();
	 TupleDesc td2 = this._innerRelation.getTupleDesc();
	 
	 return TupleDesc.combine(td1, td2);
	 
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
		//IMPLEMENT THIS
    	
    	//System.out.println("Inside Join Open");
    	this._outerRelation.open();
    	this._innerRelation.open();
    	this._innerRecent=null;
    	this._outerRecent=null;

    	
    	
    	}

    public void close() {
       //IMPLEMENT THIS
    	
    	//System.out.println("Inside Join close()");
    	this._innerRelation.close();
    	this._outerRelation.close();
    	this._innerRecent = null;
    	this._outerRecent = null;
    	

    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
//IMPLEMENT THIS
    	this._outerRelation.rewind();
    	this._innerRelation.rewind();
    	
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
    	
    	//System.out.println("Inside Join readNext method");
    	
    	
    	
	switch(_joinType){
	case SNL: return SNL_readNext();
	case PNL: return PNL_readNext();
	case BNL: return BNL_readNext();
	case SMJ: return SMJ_readNext();
	case HJ: return HJ_readNext();
	default: return SNL_readNext();
	
	}
    	
    	
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
    	
    	//System.out.println("inside SNL");
    	try{
           Tuple outer, inner;
    		
    		if(this._outerRecent!=null){
        	 outer = this._outerRecent;
        	}
    		else
    		{
    		   if(this._outerRelation.hasNext())
    			outer = this._outerRelation.next();
    		   else
    			  return null;
    		}
    			
        	
        
        		if(this._innerRelation.hasNext())
        			inner = this._innerRelation.next();
        		else
        		{
        			
        			
        			if(this._outerRelation.hasNext()){
        				
            			outer = this._outerRelation.next();
            			this._innerRelation.rewind();
            			//System.out.println("REWIND executed");
            			if(this._innerRelation.hasNext())
            			 inner=this._innerRelation.next();
            			else
            				return null;
            			}
            		  else
            			  return null;
        		}
        	
        	//System.out.println(outer.getField(0) + "     "+ inner.getField(0));
        	while(true)	{
        		
        	while(true){
        	  if(this._predicate.filter(outer, inner)){
        			this._numMatches++;
        			this._numComp++;
        			//System.out.println("Join performed ");
        			this._outerRecent=outer;
        			return this.joinTuple(outer, inner, this.getTupleDesc());
        			
        		}
        		else{
        			this._numComp++;
        		}
        		if(this._innerRelation.hasNext())
        	    inner = this._innerRelation.next();
        		else
        			
        		break;
        		
        		}
        	   
        	if(this._outerRelation.hasNext()){
        		outer=this._outerRelation.next();
        		this._innerRelation.rewind();
        	}
        	else
        		return null;
        		}
        	}	
    	catch (Exception e){
    		
    		e.printStackTrace();
    		System.out.println(e.toString());
    	}
    	
    	System.out.println("No Join Found");
    	return null;

    	
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
	//IMPLEMENT THIS (EXTRA CREDIT ONLY)
    try{
    	while(this.outerPage<=this.numberOfouterPages)
    	{
    		
    	    if(this.joinResultLeftHalf==null&&this.joinResultRightHalf==null)
    	    {   int i = this.numberOfTuples;
    	        int x = this.numberOfTuplesInOuterPage[this.outerPage] + this.numberOfTuples;
    	    	
    	        this.outerTuples2 = new ArrayList<Tuple>();
    	    	//this.outerPage++;
    	    	for(; i<x; i++)
    	    	{
    	    		this.outerTuples2.add(this.outerTuples.get(i));
    	    		this.numberOfTuples++;
    	    	}//end of for loop
    	    	
    	    	this.pos = 0;
    	    	this.PNL_supportMethod2(outerTuples2, innerTuples);
    	    }//end of if
    	    
    	    if(this.pos<this.joinResultLeftHalf.size())
    	    {
    	    Tuple t1 = this.joinResultLeftHalf.get(this.pos);
    	    Tuple t2 = this.joinResultRightHalf.get(this.pos);
    	    this.pos++;
    	    this._numMatches++;
    	    return this.joinTuple(t1, t2, this.getTupleDesc());
    	    }//end of if
    	    
    	    this.joinResultLeftHalf=null;
    	    this.joinResultRightHalf=null;
    	    this.outerPage++;
    	    this.pos=0;
    	    //end of if
    		
    	}//end of while
      }// end of try 
    		    	
    	catch(Exception e)
    	{
    		    	e.printStackTrace();
    	}//end of catch
    		    	
    return null;


    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
	
	//IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
    	try{
    	
    		
   if((this._outerTuples==null)&&(this._innerTuples==null)){
    	
    		
    	Tuple outer = null, inner = null;
    	
    	 if(this._outerRelation.hasNext()){
    		 outer=this._outerRelation.next();
    	 }
    	 
    	 if(this._innerRelation.hasNext()){
    		 inner=this._innerRelation.next();
    	 }
    	 
    	
    	 
    	if(outer==null){
    	     return null;
    	}
    	
    	if(inner==null){
    		 return null;
    	}
    	
    	
    	
    	
    	
    	System.out.println("Outer - " + outer.getField(0)+"   Inner - "+inner.getField(0));
    	
    	
    	if(outer.getField(0).compare(Predicate.Op.LESS_THAN, inner.getField(0))){
    		while(outer.getField(0).compare(Predicate.Op.LESS_THAN, inner.getField(0))){
    			if(this._outerRelation.hasNext())
    			outer=this._outerRelation.next();
    			if(outer==null){
    				return null;
    		     }
    		}
    	}
    	else if(outer.getField(0).compare(Predicate.Op.GREATER_THAN, inner.getField(0))){
    		while(outer.getField(0).compare(Predicate.Op.GREATER_THAN, inner.getField(0))){
    			if(this._innerRelation.hasNext())
    			inner=this._innerRelation.next();
    			if(inner==null){
    				return null;
    			}
    		}
    	
    	}
    		
    		
        
    	
    		
        this._outerTuples = new ArrayList<Tuple>();
    	
    	this._outerTuples.add(outer);
    	
    	Tuple temp = null;
        
    	//if(this._outerRelation.hasNext())
    	do{
    		 if(this._outerRelation.hasNext())
    		 {
    			 temp = this._outerRelation.next();
    			 this._outerRecent=temp;
    			 if(temp==null) break;
    			 if(outer.getField(0).compare(Predicate.Op.EQUALS, temp.getField(0))){
        			 this._outerTuples.add(temp); 
        		 }
        		 else
        			 break;
    		 }
    		 else{
    			 break;
    		 }
    		 }while(true);
    	
    	
    	
    	
    	
    	
    	this._innerTuples = new ArrayList<Tuple>();
    	
    	this._innerTuples.add(inner);
    	
    	Tuple temp2 = null;
    	
    	if(this._innerRelation.hasNext())
    	do{
    	
         if(this._innerRelation.hasNext())	
         {	
   		 temp2 = this._innerRelation.next();
   		 this._innerRecent=temp2;
   		 if(temp2==null) break;
   		 if(inner.getField(0).compare(Predicate.Op.EQUALS, temp2.getField(0))){
   			 this._innerTuples.add(temp2); 
   		    }
   		 else 
   			 break;
   		 }
   		 else
   			 break;
   	 	
   	    }while(true);
    	
    	
    	
    	
    	this._outerSize = this._outerTuples.size();
  		this._innerSize = this._innerTuples.size();
  		
  		
  		
  		Tuple outerResultTuple = this._outerTuples.get(this._outerIndex);
  	    
  		Tuple innerResultTuple = this._innerTuples.get(this._innerIndex++);
  		
  		
    	
    	if(this._predicate.filter(outerResultTuple, innerResultTuple)){
    		this._numComp++;
    		this._numMatches++;
    		return this.joinTuple(outerResultTuple, innerResultTuple, this.getTupleDesc());
    	}
    	
      
  		
    }	
  	
    
   else
    {   
	   
	   if(!(this._innerIndex<this._innerSize)){
 			this._outerIndex++;
 			this._innerIndex=0;
 		}
	   
	   
	   if(!(this._outerIndex<this._outerSize)){
 			this._outerTuples=null;
 			this._innerTuples=null;
 			this._outerIndex=0;
 			this._innerIndex=0;
 			this._outerSize=0;
 			this._innerSize=0;
 		}
	   else
	   {
    	Tuple outerResultTuple = this._outerTuples.get(this._outerIndex);
    
  		Tuple innerResultTuple = this._innerTuples.get(this._innerIndex++);
  		
  		
  		
  		
    	
    	if(this._predicate.filter(outerResultTuple, innerResultTuple)){
    		this._numComp++;
    		this._numMatches++;
    		return this.joinTuple(outerResultTuple, innerResultTuple, this.getTupleDesc());
    	}
    	
	   }
    	
    	
    	
    	
    	}
    	}
    	catch (Exception e){
    		System.out.println(e.getMessage());
    		System.out.println(e.toString());
    		e.printStackTrace();
    	}
	return null;
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
	//no need to implement this
	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
	//IMPLEMENT THIS
    	Tuple R = new Tuple(tupledesc);
    	TupleDesc outerTd = outer.getTupleDesc();
    	TupleDesc innerTd = inner.getTupleDesc();
    	
    	int numFieldsOuter = outerTd.numFields();
    	int numFieldsInner = innerTd.numFields();
    	
    	int i=0;
    	for(i=0;i<numFieldsOuter;i++){
    		R.setField(i, outer.getField(i));
    	}
    	
    	for(i=numFieldsOuter; i<(numFieldsOuter+numFieldsInner); i++){
    		R.setField(i, inner.getField(i-numFieldsInner));
    	}
    	
    	
	return R;
    }

    public int getNumMatches(){
	return _numMatches;
    }
    public int getNumComp(){
	return _numComp;
    }
    
    private void PNL_supportMethod(){
    	try{
    	Tuple temp;
    	this.numberOfouterPages=1;
    	this.outerTuples = new ArrayList<Tuple>();
    	
    	while(this._outerRelation.hasNext()){
    		
    		temp = this._outerRelation.next();
    		this.outerTuples.add(temp);
    		
    	}// while loop ends here
    	
    	this.numberOfouterPages =((SeqScan)this._outerRelation).getPagesRead();
    	
    	System.out.println("Number of PAGES of the outer relation = " + this.numberOfouterPages);
    	
    	this.numberOfTuplesInOuterPage = new int[this.numberOfouterPages+1];
    	
    	//this._outerRelation.close();
    	this._outerRelation.rewind();
    	
    	//System.out.println("Number of pages of the outer relation opened till now"+((SeqScan)this._outerRelation).getPagesRead());
    	
    	int i=1;
    	
    	for(i=1; i<=this.numberOfouterPages; i++){
    		while(i==(((SeqScan)this._outerRelation).getPagesRead()-numberOfouterPages)){
    			if(this._outerRelation.hasNext())
    				temp =  this._outerRelation.next();
    			else 
    				break;
    			this.numberOfTuplesInOuterPage[i]++;
    		}//end of while
    	}// end of for loop 
    	
    	for(i=1; i<=this.numberOfouterPages;i++)
    		System.out.println("PAGE " + i + " has " + this.numberOfTuplesInOuterPage[i]+" TUPLES ");
    	
    	
    	System.out.println("Total number of tuples in the Outer Relation = " + this.outerTuples.size());
    	
    	
    	
    	// for inner relation
    	
    	
    	
    	this.numberOfinnerPages = 1;
        this.innerTuples = new ArrayList<Tuple>();
    	
    	while(this._innerRelation.hasNext()){
    		
    		temp = this._innerRelation.next();
    		this.innerTuples.add(temp);
    		
    	}// while loop ends here
    	
    	this.numberOfinnerPages =((SeqScan)this._innerRelation).getPagesRead();
    	
    	System.out.println("Number of PAGES of the Inner relation = " + this.numberOfinnerPages);
    	
    	this.numberOfTuplesInInnerPage = new int[this.numberOfinnerPages+1];
    	
    	//this._outerRelation.close();
    	this._innerRelation.rewind();
    	
    	//System.out.println("Number of pages of the outer relation opened till now"+((SeqScan)this._outerRelation).getPagesRead());
    	
    	
    	
    	for(i=1; i<=this.numberOfinnerPages; i++){
    		while(i==(((SeqScan)this._innerRelation).getPagesRead()-this.numberOfinnerPages)){
    			if(this._innerRelation.hasNext())
    				temp =  this._innerRelation.next();
    			else 
    				break;
    			this.numberOfTuplesInInnerPage[i]++;
    		}//end of while
    	}// end of for loop 
    	
    	for(i=1; i<=this.numberOfinnerPages;i++)
    		System.out.println("PAGE " + i + " has " + this.numberOfTuplesInInnerPage[i]+" TUPLES ");
    	
    	
    	System.out.println("Total number of tuples in the Inner Relation = " + this.innerTuples.size());
    	
   
    	
    	
    	}// end of try
    	catch(Exception e){
    		e.printStackTrace();
    	}
    }
    
    
    private void PNL_supportMethod2(ArrayList<Tuple> outerP, ArrayList<Tuple> innerP)
    {
    	
    try{	
    	int oPSize = outerP.size();
    	int iPSize = innerP.size();
    	
    	int i=0; 
    	int j=0;
    	
    	this.joinResultLeftHalf = new ArrayList<Tuple>();
    	this.joinResultRightHalf = new ArrayList<Tuple>();
        
    	Tuple temp=null;
    	
    	for(i=0; i<oPSize; i++){
    		for(j=0; j<iPSize; j++){
    			if(this._predicate.filter(outerP.get(i), innerP.get(j))){
    				this.joinResultLeftHalf.add(outerP.get(i));
    				this.joinResultRightHalf.add(innerP.get(j));
    				this._numComp++;
    				if(this._innerRelation.hasNext())
    					temp=this._innerRelation.next();
    				
    			}// end of if
    			else {
					this._numComp++;
				}//end of else
    		}// end of for loop
    	}// end of for loop
    	this._innerRelation.rewind();
    }//end of try
    catch(Exception e)
    {
    	e.printStackTrace();
    }//
    }
    
   
    
    
    
 }
